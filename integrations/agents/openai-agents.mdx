---
title: "OpenAI Agents SDK"
description: "Use Portkey with OpenAI Agents SDK to take your AI Agents to production"
---

OpenAI Agents SDK enables the development of complex AI agents with tools, planning, and memory capabilities. Portkey enhances OpenAI Agents with observability, reliability, and production-readiness features.

## How Portkey Enhances OpenAI Agents

Portkey turns your experimental OpenAI Agents into production-ready systems by providing:

- **Complete observability** of every agent step, tool use, and interaction
- **Built-in reliability** with fallbacks, retries, and load balancing
- **Cost tracking and optimization** to manage your AI spend
- **Access to 200+ LLMs** through a single integration
- **Guardrails** to keep agent behavior safe and compliant
- **Version-controlled prompts** for consistent agent performance

<Card title="OpenAI Agents SDK Official Documentation" icon="arrow-up-right-from-square" href="https://openai.github.io/openai-agents-python/">
  Learn more about OpenAI Agents SDK's core concepts
</Card>

## Installation & Setup

<Steps>
<Step title="Install the required packages">
```bash
pip install -U openai-agents portkey-ai
```
</Step>

<Step title="Configure Portkey Client">
There are three ways to integrate Portkey with OpenAI Agents. For a simple setup, we'll use the global client approach:

```python
from agents import (
    set_default_openai_client,
    set_default_openai_api,
    Agent, Runner
)
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL
import os

# Set up Portkey as the global client
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
)

# Register as the SDK-wide default
set_default_openai_client(portkey, use_for_tracing=False)
set_default_openai_api("chat_completions")  # Responses API → Chat
```

<Info>
**What are Virtual Keys?** Virtual keys in Portkey securely store your LLM provider API keys (OpenAI, Anthropic, etc.) in an encrypted vault. They allow for easier key rotation and budget management. [Learn more about virtual keys here](/product/ai-gateway/virtual-keys).
</Info>
</Step>
</Steps>

## Getting Started

Let's create a simple question-answering agent with OpenAI Agents SDK and Portkey. This agent will respond directly to user messages using a language model:

```python
from agents import (
    set_default_openai_client,
    set_default_openai_api,
    Agent, Runner
)
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL
import os

# Set up Portkey as the global client
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
)

# Register as the SDK-wide default
set_default_openai_client(portkey, use_for_tracing=False)
set_default_openai_api("chat_completions")  # Responses API → Chat

# Create agent with any supported model
agent = Agent(
    name="Assistant",
    instructions="You are a helpful assistant.",
    model="claude-3-7-sonnet-latest"  # Using Anthropic Claude through Portkey
)

# Run the agent
result = Runner.run_sync(agent, "Tell me about quantum computing.")
print(result.final_output)
```

In this example:
1. We set up Portkey as the global client for OpenAI Agents SDK
2. We create a simple agent with instructions and a model
3. We run the agent synchronously with a user query
4. We print the final output

Visit your Portkey dashboard to see detailed logs of this agent's execution!

## Integration Approaches

There are three ways to integrate Portkey with OpenAI Agents SDK, each suited for different scenarios:

<Tabs>
  <Tab title="Global Default Client">
    Set a global client that affects all agents in your application:

```python
from agents import (
    set_default_openai_client,
    set_default_openai_api,
    set_tracing_disabled,
    Agent, Runner
)
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL
import os

# Build a Portkey-backed client
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
)

# Register it as the SDK-wide default
set_default_openai_client(portkey, use_for_tracing=False)   # skip OpenAI tracing
set_default_openai_api("chat_completions")                  # Responses API → Chat
set_tracing_disabled(True)                                  # optional

# Regular agent code—just a model name
agent = Agent(
    name="Haiku Writer",
    instructions="Respond only in haikus.",
    model="claude-3-7-sonnet-latest"
)

print(Runner.run_sync(agent, "Write a haiku on recursion.").final_output)
```

**Best for**: Whole application migration to Portkey with minimal code changes
  </Tab>

  <Tab title="ModelProvider with RunConfig">
    Use a custom ModelProvider to control which runs use Portkey:

```python
from agents import (
    Model,
    ModelProvider,
    RunConfig,
    Runner,
    Agent
)
from agents import OpenAIChatCompletionsModel           # concrete Model
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL
import os, asyncio

client = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
)

class PortkeyProvider(ModelProvider):
    def get_model(self, model_name: str | None) -> Model:
        return OpenAIChatCompletionsModel(
            model=model_name or "claude-3-7-sonnet-latest",
            openai_client=client
        )

PORTKEY = PortkeyProvider()                              # singleton is fine

async def main():
    agent = Agent(name="Assistant", instructions="Haikus only.")
    run_cfg = RunConfig(model_provider=PORTKEY)

    # Only this call uses Portkey
    out = await Runner.run(agent, "Weather in Tokyo?", run_config=run_cfg)
    print(out.final_output)

asyncio.run(main())
```

**Best for**: A/B testing, staged rollouts, or toggling between providers at runtime
  </Tab>

  <Tab title="Per-Agent Model Object">
    Attach a specific Model object to each Agent:

```python
from agents import Agent, Runner, OpenAIChatCompletionsModel
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL
import os

portkey_client = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
)

agent = Agent(
    name="Haiku Writer",
    instructions="Classic Japanese form.",
    model=OpenAIChatCompletionsModel(                   # concrete Model
        model="claude-3-7-sonnet-latest",
        openai_client=portkey_client
    ),
)

print(Runner.run_sync(agent, "Recursion haiku.").final_output)
```

**Best for**: Mixed agent environments where different agents need different providers or configurations
  </Tab>
</Tabs>

**Comparing the 3 approaches**

| Strategy | Code Touchpoints | Best For |
|----------|-----------------|----------|
| **Global Client** via `set_default_openai_client` | One-time setup; agents need only model names | Whole app uses Portkey; simplest migration |
| **ModelProvider in RunConfig** | Add a provider + pass `run_config` | Toggle Portkey per run; A/B tests, staged rollouts |
| **Explicit Model per Agent** | Specify `OpenAIChatCompletionsModel` in agent | Mixed fleet: each agent can talk to a different provider |

<Accordion title="End-to-End Example: Research Agent with Tools">
Here's a more comprehensive agent that can use tools to perform tasks:

```python
from agents import Agent, Runner, Tool, set_default_openai_client
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL
import os

# Configure Portkey client
portkey = AsyncOpenAI(
    api_key=os.environ.get("PORTKEY_API_KEY"),
    base_url=PORTKEY_GATEWAY_URL
)
set_default_openai_client(portkey)

# Define agent tools
def get_weather(location: str) -> str:
    """Get the current weather for a location."""
    return f"It's 72°F and sunny in {location}."

def search_web(query: str) -> str:
    """Search the web for information."""
    return f"Found information about: {query}"

# Create agent with tools
agent = Agent(
    name="Research Assistant",
    instructions="You are a helpful assistant that can search for information and check the weather.",
    model="claude-3-opus-20240229",
    tools=[
        Tool(
            name="get_weather",
            description="Get current weather for a location",
            input_schema={
                "location": {
                    "type": "string",
                    "description": "City and state, e.g. San Francisco, CA"
                }
            },
            callback=get_weather
        ),
        Tool(
            name="search_web",
            description="Search the web for information",
            input_schema={
                "query": {
                    "type": "string",
                    "description": "Search query"
                }
            },
            callback=search_web
        )
    ]
)

# Run the agent
result = Runner.run_sync(
    agent,
    "What's the weather in San Francisco and find information about Golden Gate Bridge?"
)
print(result.final_output)
```

Visit your Portkey dashboard to see the complete execution flow visualized!
</Accordion>



## Enhanced Observability

Portkey provides comprehensive observability for your OpenAI Agents, helping you understand exactly what's happening during each execution.

<Tabs>
  <Tab title="Traces">

<Frame>
    <img src="/images/product/product-11-1.webp"/>
</Frame>


    Traces provide a hierarchical view of your agent's execution, showing the sequence of LLM calls, tool invocations, and state transitions.

  ```python
    # Add tracing to your OpenAI Agents
    portkey = AsyncOpenAI(
        base_url=PORTKEY_GATEWAY_URL,
        api_key=os.environ["PORTKEY_API_KEY"],
        default_headers=createHeaders(
            trace_id="unique_execution_trace_id", # Add unique trace ID
        )
    )
    set_default_openai_client(portkey)
  ```

  </Tab>

  <Tab title="Logs">
      <Frame>
          <img src="/images/product/product-2.avif"/>
      </Frame>

    Portkey logs every interaction with LLMs, including:

    - Complete request and response payloads
    - Latency and token usage metrics
    - Cost calculations
    - Tool calls and function executions

    All logs can be filtered by metadata, trace IDs, models, and more, making it easy to debug specific agent runs.
  </Tab>

  <Tab title="Metrics & Dashboards">
      <Frame>
          <img src="/images/product/dashboard.png"/>
      </Frame>

    Portkey provides built-in dashboards that help you:

    - Track cost and token usage across all agent runs
    - Analyze performance metrics like latency and success rates
    - Identify bottlenecks in your agent workflows
    - Compare different agent configurations and LLMs

    You can filter and segment all metrics by custom metadata to analyze specific agent types, user groups, or use cases.
  </Tab>

  <Tab title="Metadata Filtering">
      <Frame>
        <img src="/images/metadata.png" alt="Analytics with metadata filters" />
      </Frame>



    Add custom metadata to your LangGraph agent calls to enable powerful filtering and segmentation:
    ```python

      # Add tracing to your OpenAI Agents
      portkey = AsyncOpenAI(
          base_url=PORTKEY_GATEWAY_URL,
          api_key=os.environ["PORTKEY_API_KEY"],
          default_headers=createHeaders(
              metadata={"agent_type": "research_agent"} # Add custom metadata
          )
      )
      set_default_openai_client(portkey)
    ```

    This metadata can be used to filter logs, traces, and metrics on the Portkey dashboard, allowing you to analyze specific agent runs, users, or environments.
  </Tab>
</Tabs>



## Reliability - Keep Your Agents Running Smoothly

When running agents in production, things can go wrong - API rate limits, network issues, or provider outages. Portkey's reliability features ensure your agents keep running smoothly even when problems occur.

It's this simple to enable fallback in your OpenAI Agents:

```python
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL
from openai import AsyncOpenAI
from agents import set_default_openai_client

# Create a config with fallbacks
config = {
  "strategy": {
    "mode": "fallback"
  },
  "targets": [
    {
      "provider": "openai",
      "override_params": {"model": "gpt-4o"}
    },
    {
      "provider": "anthropic",
      "override_params": {"model": "claude-3-opus-20240229"}
    }
  ]
}

# Configure Portkey client with fallback config
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
    default_headers=createHeaders(config=config)
)
set_default_openai_client(portkey)
```

This configuration will automatically try Claude if the GPT-4o request fails, ensuring your agent can continue operating.

<CardGroup cols="2">
  <Card title="Automatic Retries" icon="rotate" href="../../product/ai-gateway/automatic-retries">
    Handles temporary failures automatically. If an LLM call fails, Portkey will retry the same request for the specified number of times - perfect for rate limits or network blips.
  </Card>
  <Card title="Request Timeouts" icon="clock" href="../../product/ai-gateway/request-timeouts">
    Prevent your agents from hanging. Set timeouts to ensure you get responses (or can fail gracefully) within your required timeframes.
  </Card>
  <Card title="Conditional Routing" icon="route" href="../../product/ai-gateway/conditional-routing">
    Send different requests to different providers. Route complex reasoning to GPT-4, creative tasks to Claude, and quick responses to Gemini based on your needs.
  </Card>
  <Card title="Fallbacks" icon="shield" href="../../product/ai-gateway/fallbacks">
    Keep running even if your primary provider fails. Automatically switch to backup providers to maintain availability.
  </Card>
  <Card title="Load Balancing" icon="scale-balanced" href="../../product/ai-gateway/load-balancing">
    Spread requests across multiple API keys or providers. Great for high-volume agent operations and staying within rate limits.
  </Card>
</CardGroup>

## Prompting in OpenAI Agents

Portkey's Prompt Engineering Studio helps you create, manage, and optimize the prompts used in your OpenAI Agents. Instead of hardcoding prompts or instructions, use Portkey's prompt rendering API to dynamically fetch and apply your versioned prompts.


<Frame caption="Manage prompts in Portkey's Prompt Library">
![Prompt Playground Interface](/images/product/ai-gateway/ai-20.webp)
</Frame>

<Tabs>


  <Tab title="Prompt Playground">

Prompt Playground is a place to compare, test and deploy perfect prompts for your AI application. It’s where you experiment with different models, test variables, compare outputs, and refine your prompt engineering strategy before deploying to production. It allows you to:

    1. Iteratively develop prompts before using them in your agents
    2. Test prompts with different variables and models
    3. Compare outputs between different prompt versions
    4. Collaborate with team members on prompt development

    This visual environment makes it easier to craft effective prompts for each step in your LangGraph agent's workflow.
  </Tab>

  <Tab title="Using Prompt Templates">

The Prompt Render API retrieves your prompt templates with all parameters configured:

```python
from portkey_ai import Portkey
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL
from agents import Agent, Runner, set_default_openai_client

# Initialize Portkey client
portkey_client = Portkey(api_key="PORTKEY_API_KEY")

# Retrieve prompt using the render API
prompt_data = portkey_client.prompts.render(
    prompt_id="YOUR_PROMPT_ID",
    variables={
        "user_input": "Tell me about artificial intelligence"
    }
)

# Configure OpenAI client with Portkey
openai_client = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key="YOUR_PORTKEY_API_KEY",
)
set_default_openai_client(openai_client)

# Use the rendered prompt in your OpenAI Agent
agent = Agent(
    name="Assistant",
    instructions=prompt_data.data.messages[0]["content"],  # Use the rendered prompt as instructions
    model="claude-3-opus-20240229"
)

result = Runner.run_sync(agent, "Tell me about artificial intelligence")
print(result.final_output)
```
  </Tab>

  <Tab title="Prompt Versioning">


You can:
- Create multiple versions of the same prompt
- Compare performance between versions
- Roll back to previous versions if needed
- Specify which version to use in your code:

```python
# Use a specific prompt version
prompt_data = portkey_client.prompts.render(
    prompt_id="YOUR_PROMPT_ID@version_number",
    variables={
        "user_input": "Tell me about quantum computing"
    }
)
```

  </Tab>


  <Tab title="Mustache Templating for variables">

Portkey prompts use Mustache-style templating for easy variable substitution:

```
You are an AI assistant helping with {{task_type}}.

User question: {{user_input}}

Please respond in a {{tone}} tone and include {{required_elements}}.
```

When rendering, simply pass the variables:

```python
prompt_data = portkey_client.prompts.render(
    prompt_id="YOUR_PROMPT_ID",
    variables={
        "task_type": "research",
        "user_input": "Tell me about quantum computing",
        "tone": "professional",
        "required_elements": "recent academic references"
    }
)
```
    </Tab>
</Tabs>

<Card title="Prompt Engineering Studio" icon="wand-magic-sparkles" href="/product/prompt-library">
  Learn more about Portkey's prompt management features
</Card>

## Guardrails for Safe Agents

Guardrails ensure your OpenAI Agents operate safely and respond appropriately in all situations.


**Why Use Guardrails?**

OpenAI Agents can experience various failure modes:
- Generating harmful or inappropriate content
- Leaking sensitive information like PII
- Hallucinating incorrect information
- Generating outputs in incorrect formats

Portkey's guardrails protect against these issues by validating both inputs and outputs.

**Implementing Guardrails**

```python
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL
from openai import AsyncOpenAI
from agents import set_default_openai_client

# Create a config with input and output guardrails
config = {
    "virtual_key": "openai-xxx",
    "input_guardrails": ["guardrails-id-xxx", "guardrails-id-yyy"],
    "output_guardrails": ["guardrails-id-xxx"]
}

# Configure OpenAI client with guardrails
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
    default_headers=createHeaders(config=config)
)
set_default_openai_client(portkey)
```

Portkey's guardrails can:
- Detect and redact PII in both inputs and outputs
- Filter harmful or inappropriate content
- Validate response formats against schemas
- Check for hallucinations against ground truth
- Apply custom business logic and rules

<Card title="Learn More About Guardrails" icon="shield-check" href="/product/guardrails">
  Explore Portkey's guardrail features to enhance agent safety
</Card>

## User Tracking with Metadata

Track individual users through your OpenAI Agents using Portkey's metadata system.

### What is Metadata in Portkey?

Metadata allows you to associate custom data with each request, enabling filtering, segmentation, and analytics. The special `_user` field is specifically designed for user tracking.

```python
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL
from openai import AsyncOpenAI
from agents import set_default_openai_client

# Configure client with user tracking
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
    default_headers=createHeaders(
        virtual_key="YOUR_LLM_PROVIDER_VIRTUAL_KEY",
        metadata={
            "_user": "user_123", # Special _user field for user analytics
            "user_name": "John Doe",
            "user_tier": "premium",
            "user_company": "Acme Corp"
        }
    )
)
set_default_openai_client(portkey)
```

**Filter Analytics by User**

With metadata in place, you can filter analytics by user and analyze performance metrics on a per-user basis:

<Frame caption="Filter analytics by user">
  <img src="/images/metadata-filters.png"/>
</Frame>


This enables:
- Per-user cost tracking and budgeting
- Personalized user analytics
- Team or organization-level metrics
- Environment-specific monitoring (staging vs. production)

<Card title="Learn More About Metadata" icon="tags" href="/product/observability/metadata">
  Explore how to use custom metadata to enhance your analytics
</Card>

## Function Calling in OpenAI Agents

OpenAI Agents SDK natively supports tools that enable your agents to interact with external systems and APIs. Portkey provides full observability for tool usage in your agents:

```python [expandable]
from agents import Agent, Runner, Tool, set_default_openai_client
from openai import AsyncOpenAI
from portkey_ai import PORTKEY_GATEWAY_URL, createHeaders
import os

# Configure Portkey client with tracing
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
    default_headers=createHeaders(
        trace_id="tools_example",
        metadata={"agent_type": "research"}
    )
)
set_default_openai_client(portkey)

# Define tools
def get_weather(location: str, unit: str = "fahrenheit") -> str:
    """Get the current weather in a given location"""
    return f"The weather in {location} is 72 degrees {unit}"

def get_population(city: str, country: str) -> str:
    """Get the population of a city"""
    return f"The population of {city}, {country} is 1,000,000"

# Create agent with tools
agent = Agent(
    name="Research Assistant",
    instructions="You are a helpful assistant that can look up weather and population information.",
    model="claude-3-opus-20240229",
    tools=[
        Tool(
            name="get_weather",
            description="Get the current weather in a given location",
            input_schema={
                "location": {
                    "type": "string",
                    "description": "City and state, e.g. San Francisco, CA"
                },
                "unit": {
                    "type": "string",
                    "description": "Temperature unit (celsius or fahrenheit)",
                    "default": "fahrenheit"
                }
            },
            callback=get_weather
        ),
        Tool(
            name="get_population",
            description="Get the population of a city",
            input_schema={
                "city": {
                    "type": "string",
                    "description": "City name"
                },
                "country": {
                    "type": "string",
                    "description": "Country name"
                }
            },
            callback=get_population
        )
    ]
)

# Run the agent
result = Runner.run_sync(
    agent,
    "What's the weather in San Francisco and what's the population of Tokyo, Japan?"
)
print(result.final_output)
```




## Model Interoperability

With Portkey, you can easily switch between different LLMs in your OpenAI Agents without changing your core agent logic.

```python
# Configure Portkey with different LLM providers
from portkey_ai import createHeaders, PORTKEY_GATEWAY_URL
from openai import AsyncOpenAI
from agents import set_default_openai_client

# Using OpenAI
openai_config = {
    "provider": "openai",
    "api_key": "YOUR_OPENAI_API_KEY",
    "override_params": {
        "model": "gpt-4o"
    }
}

# Using Anthropic
anthropic_config = {
    "provider": "anthropic",
    "api_key": "YOUR_ANTHROPIC_API_KEY",
    "override_params": {
        "model": "claude-3-opus-20240229"
    }
}

# Choose which config to use
active_config = openai_config  # or anthropic_config

# Configure OpenAI client with chosen provider
portkey = AsyncOpenAI(
    base_url=PORTKEY_GATEWAY_URL,
    api_key=os.environ["PORTKEY_API_KEY"],
    default_headers=createHeaders(config=active_config)
)
set_default_openai_client(portkey)

# Create and run agent - no changes needed in agent code
agent = Agent(
    name="Assistant",
    instructions="You are a helpful assistant.",
    # The model specified here will be used as a reference but the actual model
    # is determined by the active_config
    model="gpt-4o"
)

result = Runner.run_sync(agent, "Tell me about quantum computing.")
print(result.final_output)
```

Portkey provides access to over 200 LLMs through a unified interface, including:

- OpenAI (GPT-4o, GPT-4 Turbo, etc.)
- Anthropic (Claude 3.5 Sonnet, Claude 3 Opus, etc.)
- Mistral AI (Mistral Large, Mistral Medium, etc.)
- Google Vertex AI (Gemini 1.5 Pro, etc.)
- Cohere (Command, Command-R, etc.)
- AWS Bedrock (Claude, Titan, etc.)
- Local/Private Models

<Card title="Supported Providers" icon="server" href="/integrations/llms">
  See the full list of LLM providers supported by Portkey
</Card>

## Frequently Asked Questions

<AccordionGroup>
  <Accordion title="How does Portkey enhance OpenAI Agents?">
    Portkey adds production-readiness to OpenAI Agents through comprehensive observability (traces, logs, metrics), reliability features (fallbacks, retries, caching), and access to 200+ LLMs through a unified interface. This makes it easier to debug, optimize, and scale your agent applications.
  </Accordion>

  <Accordion title="Can I use Portkey with existing OpenAI Agents?">
    Yes! Portkey integrates seamlessly with existing OpenAI Agents. You only need to replace your client initialization code with the Portkey-enabled version. The rest of your agent code remains unchanged.
  </Accordion>

  <Accordion title="Does Portkey work with all OpenAI Agents features?">
    Portkey supports all OpenAI Agents SDK features, including tool use, memory, planning, and more. It adds observability and reliability without limiting any of the SDK's functionality.
  </Accordion>

  <Accordion title="How does Portkey handle streaming in OpenAI Agents?">
    Portkey fully supports streaming responses in OpenAI Agents. You can enable streaming by using the appropriate methods in the OpenAI Agents SDK, and Portkey will properly track and log the streaming interactions.
  </Accordion>

  <Accordion title="How do I filter logs and traces for specific agent runs?">
    Portkey allows you to add custom metadata to your agent runs, which you can then use for filtering. Add fields like `agent_name`, `agent_type`, or `session_id` to easily find and analyze specific agent executions.
  </Accordion>

  <Accordion title="Can I use my own API keys with Portkey?">
    Yes! Portkey uses your own API keys for the various LLM providers. It securely stores them as virtual keys, allowing you to easily manage and rotate keys without changing your code.
  </Accordion>
</AccordionGroup>

## Resources

<CardGroup cols="3">

  <Card title="OpenAI Agents Docs" href="https://openai.github.io/openai-agents-python/">
    <p>Official OpenAI Agents SDK documentation</p>
  </Card>

  <Card title="Agent Examples" href="https://github.com/openai/openai-agents-python/tree/main/examples">
    <p>Example implementations for various use cases</p>
  </Card>

  <Card title="Book a Demo" href="https://portkey.sh/openai-agents">
    <p>Get personalized guidance on implementing this integration</p>
  </Card>
</CardGroup>
